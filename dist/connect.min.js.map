{"version":3,"file":"connect.min.js","sources":["../src/state.ts","../src/events.ts","../src/meta.ts","../src/actions.ts","../src/index.ts"],"sourcesContent":["export interface StateOptions {\r\n  persistence?: 'window' | 'session' | 'local';\r\n  expiry?: number; // milliseconds from now\r\n}\r\n\r\ninterface StateStore {\r\n  value: unknown;\r\n  expiry?: number;\r\n  persistence: string;\r\n}\r\n\r\ntype StateCallback = (value: unknown, oldValue: unknown) => void;\r\n\r\nconst subscribers = new Map<string, Set<StateCallback>>();\r\nconst memoryStore = new Map<string, StateStore>();\r\nconst STORAGE_PREFIX = 'cc:';\r\n\r\nfunction getStorage(persistence: string): Storage | null {\r\n  switch (persistence) {\r\n    case 'session':\r\n      return typeof sessionStorage !== 'undefined' ? sessionStorage : null;\r\n    case 'local':\r\n      return typeof localStorage !== 'undefined' ? localStorage : null;\r\n    default:\r\n      return null; // window/memory\r\n  }\r\n}\r\n\r\nfunction isExpired(store: StateStore): boolean {\r\n  return store.expiry !== undefined && Date.now() > store.expiry;\r\n}\r\n\r\nexport const state = {\r\n  /**\r\n   * Get a value from state\r\n   */\r\n  get<T = unknown>(key: string): T | undefined {\r\n    // Check memory first\r\n    const mem = memoryStore.get(key);\r\n    if (mem) {\r\n      if (isExpired(mem)) {\r\n        this.delete(key);\r\n        return undefined;\r\n      }\r\n      return mem.value as T;\r\n    }\r\n\r\n    // Check persistent stores (session first, then local)\r\n    for (const storageType of ['session', 'local'] as const) {\r\n      const storage = getStorage(storageType);\r\n      if (!storage) continue;\r\n\r\n      const raw = storage.getItem(`${STORAGE_PREFIX}${key}`);\r\n      if (raw) {\r\n        try {\r\n          const parsed = JSON.parse(raw) as StateStore;\r\n          if (isExpired(parsed)) {\r\n            storage.removeItem(`${STORAGE_PREFIX}${key}`);\r\n            continue;\r\n          }\r\n          return parsed.value as T;\r\n        } catch {\r\n          // Invalid JSON, remove it\r\n          storage.removeItem(`${STORAGE_PREFIX}${key}`);\r\n        }\r\n      }\r\n    }\r\n\r\n    return undefined;\r\n  },\r\n\r\n  /**\r\n   * Set a value in state\r\n   */\r\n  set(key: string, value: unknown, options: StateOptions = {}): void {\r\n    const { persistence = 'window', expiry } = options;\r\n    const oldValue = this.get(key);\r\n\r\n    const store: StateStore = {\r\n      value,\r\n      persistence,\r\n      expiry: expiry ? Date.now() + expiry : undefined\r\n    };\r\n\r\n    const storage = getStorage(persistence);\r\n    if (storage) {\r\n      storage.setItem(`${STORAGE_PREFIX}${key}`, JSON.stringify(store));\r\n    } else {\r\n      memoryStore.set(key, store);\r\n    }\r\n\r\n    // Notify subscribers\r\n    const subs = subscribers.get(key);\r\n    if (subs) {\r\n      subs.forEach(cb => {\r\n        try {\r\n          cb(value, oldValue);\r\n        } catch (e) {\r\n          console.error(`Error in state subscriber for \"${key}\":`, e);\r\n        }\r\n      });\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Check if a key exists in state\r\n   */\r\n  has(key: string): boolean {\r\n    return this.get(key) !== undefined;\r\n  },\r\n\r\n  /**\r\n   * Delete a key from state\r\n   */\r\n  delete(key: string): void {\r\n    const oldValue = this.get(key);\r\n\r\n    // Remove from all stores\r\n    memoryStore.delete(key);\r\n\r\n    const session = getStorage('session');\r\n    const local = getStorage('local');\r\n\r\n    session?.removeItem(`${STORAGE_PREFIX}${key}`);\r\n    local?.removeItem(`${STORAGE_PREFIX}${key}`);\r\n\r\n    // Notify subscribers of deletion\r\n    const subs = subscribers.get(key);\r\n    if (subs && oldValue !== undefined) {\r\n      subs.forEach(cb => {\r\n        try {\r\n          cb(undefined, oldValue);\r\n        } catch (e) {\r\n          console.error(`Error in state subscriber for \"${key}\":`, e);\r\n        }\r\n      });\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Subscribe to changes on a key\r\n   */\r\n  subscribe(key: string, callback: StateCallback): void {\r\n    if (!subscribers.has(key)) {\r\n      subscribers.set(key, new Set());\r\n    }\r\n    subscribers.get(key)!.add(callback);\r\n  },\r\n\r\n  /**\r\n   * Unsubscribe from changes on a key\r\n   */\r\n  unsubscribe(key: string, callback: StateCallback): void {\r\n    subscribers.get(key)?.delete(callback);\r\n  },\r\n\r\n  /**\r\n   * Clear all state (useful for testing or logout)\r\n   */\r\n  clear(): void {\r\n    // Clear memory\r\n    memoryStore.clear();\r\n\r\n    // Clear persistent storage with our prefix\r\n    for (const storageType of ['session', 'local'] as const) {\r\n      const storage = getStorage(storageType);\r\n      if (!storage) continue;\r\n\r\n      const keysToRemove: string[] = [];\r\n      for (let i = 0; i < storage.length; i++) {\r\n        const key = storage.key(i);\r\n        if (key?.startsWith(STORAGE_PREFIX)) {\r\n          keysToRemove.push(key);\r\n        }\r\n      }\r\n      keysToRemove.forEach(k => storage.removeItem(k));\r\n    }\r\n\r\n    // Clear subscribers\r\n    subscribers.clear();\r\n  }\r\n};\r\n","export type EventHandler<T = unknown> = (payload: T) => void;\r\n\r\nconst handlers = new Map<string, Set<EventHandler>>();\r\n\r\nexport const events = {\r\n  /**\r\n   * Emit an event with optional payload\r\n   */\r\n  emit<T = unknown>(eventName: string, payload?: T): void {\r\n    const eventHandlers = handlers.get(eventName);\r\n    if (!eventHandlers) return;\r\n\r\n    eventHandlers.forEach(handler => {\r\n      try {\r\n        handler(payload);\r\n      } catch (e) {\r\n        console.error(`Error in event handler for \"${eventName}\":`, e);\r\n      }\r\n    });\r\n  },\r\n\r\n  /**\r\n   * Subscribe to an event\r\n   */\r\n  on<T = unknown>(eventName: string, handler: EventHandler<T>): void {\r\n    if (!handlers.has(eventName)) {\r\n      handlers.set(eventName, new Set());\r\n    }\r\n    handlers.get(eventName)!.add(handler as EventHandler);\r\n  },\r\n\r\n  /**\r\n   * Unsubscribe from an event\r\n   */\r\n  off<T = unknown>(eventName: string, handler: EventHandler<T>): void {\r\n    handlers.get(eventName)?.delete(handler as EventHandler);\r\n  },\r\n\r\n  /**\r\n   * Subscribe to an event once (auto-unsubscribes after first call)\r\n   */\r\n  once<T = unknown>(eventName: string, handler: EventHandler<T>): void {\r\n    const wrapper: EventHandler<T> = (payload) => {\r\n      this.off(eventName, wrapper);\r\n      handler(payload);\r\n    };\r\n    this.on(eventName, wrapper);\r\n  },\r\n\r\n  /**\r\n   * Clear all handlers for an event, or all events if no name provided\r\n   */\r\n  clear(eventName?: string): void {\r\n    if (eventName) {\r\n      handlers.delete(eventName);\r\n    } else {\r\n      handlers.clear();\r\n    }\r\n  }\r\n};\r\n","export interface MetaStore {\r\n  env: string;\r\n  page: Record<string, unknown>;\r\n  site: Record<string, unknown>;\r\n  features: Record<string, boolean>;\r\n  [key: string]: unknown;\r\n}\r\n\r\nlet metaData: MetaStore = {\r\n  env: 'production',\r\n  page: {},\r\n  site: {},\r\n  features: {}\r\n};\r\n\r\n/**\r\n * Get a nested value from an object using dot notation\r\n */\r\nfunction getNestedValue(obj: Record<string, unknown>, path: string): unknown {\r\n  return path.split('.').reduce((current: unknown, key) => {\r\n    if (current && typeof current === 'object' && key in current) {\r\n      return (current as Record<string, unknown>)[key];\r\n    }\r\n    return undefined;\r\n  }, obj);\r\n}\r\n\r\nexport const meta = {\r\n  /**\r\n   * Initialize meta data (typically called once at app startup)\r\n   */\r\n  init(data: Partial<MetaStore>): void {\r\n    metaData = { ...metaData, ...data };\r\n  },\r\n\r\n  /**\r\n   * Get meta value by key (supports dot notation for nested values)\r\n   * @example meta.get('env') // 'production'\r\n   * @example meta.get('page.title') // 'Home'\r\n   * @example meta.get('features.beta') // true\r\n   */\r\n  get<T = unknown>(key: string): T | undefined {\r\n    // Check for top-level key first\r\n    if (key in metaData && !key.includes('.')) {\r\n      return metaData[key] as T;\r\n    }\r\n    // Support dot notation\r\n    return getNestedValue(metaData, key) as T | undefined;\r\n  },\r\n\r\n  /**\r\n   * Check if a meta key exists and is truthy\r\n   * Useful for feature flags: meta.has('features.beta')\r\n   */\r\n  has(key: string): boolean {\r\n    const value = this.get(key);\r\n    return value !== undefined && value !== null && value !== false;\r\n  },\r\n\r\n  /**\r\n   * Set a meta value at runtime\r\n   */\r\n  set(key: string, value: unknown): void {\r\n    if (!key.includes('.')) {\r\n      metaData[key] = value;\r\n      return;\r\n    }\r\n\r\n    // Handle nested keys\r\n    const parts = key.split('.');\r\n    const lastKey = parts.pop()!;\r\n    let current: Record<string, unknown> = metaData;\r\n\r\n    for (const part of parts) {\r\n      if (!(part in current) || typeof current[part] !== 'object') {\r\n        current[part] = {};\r\n      }\r\n      current = current[part] as Record<string, unknown>;\r\n    }\r\n\r\n    current[lastKey] = value;\r\n  },\r\n\r\n  /**\r\n   * Get all meta data (for debugging)\r\n   */\r\n  getAll(): MetaStore {\r\n    return { ...metaData };\r\n  }\r\n};\r\n","export interface ApiOptions extends Omit<RequestInit, 'method' | 'body'> {\r\n  body?: unknown;\r\n  timeout?: number;\r\n}\r\n\r\nexport interface ApiResponse<T = unknown> {\r\n  data: T;\r\n  status: number;\r\n  ok: boolean;\r\n}\r\n\r\nexport const actions = {\r\n  /**\r\n   * Make an API request\r\n   */\r\n  async api<T = unknown>(\r\n    url: string,\r\n    method: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE' = 'GET',\r\n    options: ApiOptions = {}\r\n  ): Promise<ApiResponse<T>> {\r\n    const { body, timeout = 30000, headers = {}, ...restOptions } = options;\r\n\r\n    const controller = new AbortController();\r\n    const timeoutId = setTimeout(() => controller.abort(), timeout);\r\n\r\n    try {\r\n      const fetchOptions: RequestInit = {\r\n        method,\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n          ...headers\r\n        },\r\n        signal: controller.signal,\r\n        ...restOptions\r\n      };\r\n\r\n      if (body !== undefined && method !== 'GET') {\r\n        fetchOptions.body = JSON.stringify(body);\r\n      }\r\n\r\n      const response = await fetch(url, fetchOptions);\r\n      clearTimeout(timeoutId);\r\n\r\n      let data: T;\r\n      const contentType = response.headers.get('content-type');\r\n\r\n      if (contentType?.includes('application/json')) {\r\n        data = await response.json();\r\n      } else {\r\n        data = await response.text() as unknown as T;\r\n      }\r\n\r\n      return {\r\n        data,\r\n        status: response.status,\r\n        ok: response.ok\r\n      };\r\n    } catch (error) {\r\n      clearTimeout(timeoutId);\r\n\r\n      if (error instanceof Error && error.name === 'AbortError') {\r\n        throw new Error(`Request timeout after ${timeout}ms`);\r\n      }\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Focus an element by selector\r\n   */\r\n  focus(selector: string): boolean {\r\n    const el = document.querySelector<HTMLElement>(selector);\r\n    if (el) {\r\n      el.focus();\r\n      return true;\r\n    }\r\n    return false;\r\n  },\r\n\r\n  /**\r\n   * Scroll an element into view\r\n   */\r\n  scroll(selector: string, options?: ScrollIntoViewOptions): boolean {\r\n    const el = document.querySelector(selector);\r\n    if (el) {\r\n      el.scrollIntoView(options ?? { behavior: 'smooth' });\r\n      return true;\r\n    }\r\n    return false;\r\n  },\r\n\r\n  /**\r\n   * Delay execution for a specified time\r\n   */\r\n  delay(ms: number): Promise<void> {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n  },\r\n\r\n  /**\r\n   * Copy text to clipboard\r\n   */\r\n  async copyToClipboard(text: string): Promise<boolean> {\r\n    try {\r\n      await navigator.clipboard.writeText(text);\r\n      return true;\r\n    } catch {\r\n      // Fallback for older browsers\r\n      const textarea = document.createElement('textarea');\r\n      textarea.value = text;\r\n      textarea.style.position = 'fixed';\r\n      textarea.style.opacity = '0';\r\n      document.body.appendChild(textarea);\r\n      textarea.select();\r\n\r\n      try {\r\n        document.execCommand('copy');\r\n        return true;\r\n      } catch {\r\n        return false;\r\n      } finally {\r\n        document.body.removeChild(textarea);\r\n      }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Read from clipboard\r\n   */\r\n  async readClipboard(): Promise<string | null> {\r\n    try {\r\n      return await navigator.clipboard.readText();\r\n    } catch {\r\n      return null;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Dispatch a custom DOM event on an element\r\n   */\r\n  dispatchEvent(selector: string, eventName: string, detail?: unknown): boolean {\r\n    const el = document.querySelector(selector);\r\n    if (el) {\r\n      el.dispatchEvent(new CustomEvent(eventName, {\r\n        detail,\r\n        bubbles: true,\r\n        composed: true\r\n      }));\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n};\r\n","import { state, StateOptions } from './state';\r\nimport { events, EventHandler } from './events';\r\nimport { meta, MetaStore } from './meta';\r\nimport { actions, ApiOptions, ApiResponse } from './actions';\r\n\r\nexport interface CC {\r\n  state: typeof state;\r\n  events: typeof events;\r\n  meta: typeof meta;\r\n  actions: typeof actions;\r\n}\r\n\r\nexport const cc: CC = {\r\n  state,\r\n  events,\r\n  meta,\r\n  actions\r\n};\r\n\r\n// Auto-attach to window in browser environments\r\nif (typeof window !== 'undefined') {\r\n  (window as unknown as { cc: CC }).cc = cc;\r\n}\r\n\r\n// Named exports for ESM usage\r\nexport { state, events, meta, actions };\r\nexport type { StateOptions, EventHandler, MetaStore, ApiOptions, ApiResponse };\r\n\r\n// Default export\r\nexport default cc;\r\n"],"names":["subscribers","Map","memoryStore","STORAGE_PREFIX","getStorage","persistence","sessionStorage","localStorage","isExpired","store","undefined","expiry","Date","now","state","get","key","mem","this","delete","value","storageType","storage","raw","getItem","parsed","JSON","parse","removeItem","set","options","oldValue","setItem","stringify","subs","forEach","cb","e","console","error","has","session","local","subscribe","callback","Set","add","unsubscribe","clear","keysToRemove","i","length","startsWith","push","k","handlers","events","emit","eventName","payload","eventHandlers","handler","on","off","once","wrapper","metaData","env","page","site","features","meta","init","data","includes","obj","split","reduce","current","parts","lastKey","pop","part","getAll","actions","api","url","method","body","timeout","headers","restOptions","controller","AbortController","timeoutId","setTimeout","abort","fetchOptions","signal","response","fetch","clearTimeout","contentType","json","text","status","ok","Error","name","focus","selector","el","document","querySelector","scroll","scrollIntoView","behavior","delay","ms","Promise","resolve","copyToClipboard","navigator","clipboard","writeText","textarea","createElement","style","position","opacity","appendChild","select","execCommand","removeChild","readClipboard","readText","dispatchEvent","detail","CustomEvent","bubbles","composed","cc","window"],"mappings":"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"}